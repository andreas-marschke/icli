#!/usr/bin/env perl
use autodie;
use strict;
use warnings;
use 5.010;

use Getopt::Long;
use Term::ANSIColor;

my ($data, $cache, $extra);
my $status_file = '/var/lib/icinga/status.dat';
my $context;
my $colours = 1;
my $short = 0;
my ($for_host);


sub with_colour {
	my ($text, $colour) = @_;
	if ($colours) {
		return colored($text, $colour);
	}
	else {
		return $text;
	}
}

sub read_status_line {
	my ($line) = @_;

	if ($line =~ / ^ (?<context> \w+) \s+ { /x) {
		$context = $+{context};
	}
	elsif ($line =~ / ^ \t* (?<key> [^=]+ ) = (?<value> .*) $ /x) {
		$cache->{$+{key}} = $+{value};
	}
	elsif ($line =~ / ^ \t* } \s* $ /x) {
		given($context) {
			when(['info', 'programstatus']) {
				$data->{$context} = $cache;
			}
			when('hoststatus') {
				push(@{$data->{hosts}}, $cache);
			}
			when('servicestatus') {
				push(@{$data->{services}->{$cache->{host_name}}}, $cache);
				if ($cache->{current_state} != 0) {
					$extra->{$cache->{host_name}}->{service_problem} = 1;
				}
			}
			when('contactstatus') {
				push(@{$data->{contacts}}, $cache);
			}
			default {
				warn("Unknown field in $status_file: $context\n");
			}
		}
		$cache = undef;
	}
}

sub read_status {
	open(my $fh, '<', $status_file);
	while (my $line = <$fh>) {
		chomp($line);
		read_status_line($line);
	}
	close($fh);
}

sub state_to_string {
	my ($digit) = @_;
	given ($digit) {
		when(0) { return with_colour('   OK   ', 'black on_green' ) }
		when(1) { return with_colour(' WARNING', 'black on_yellow') }
		when(2) { return with_colour('CRITICAL', 'white on_red'   ) }
		when(3) { return with_colour(' UNKNOWN', 'white on_blue'  ) }
		default { return with_colour('  ???   ', 'white'          ) }
	}
}

sub display_service {
	my ($s) = @_;
	printf(
		"%-20.20s %s %s\n",
		$s->{service_description},
		state_to_string($s->{current_state}),
		$s->{plugin_output},
	);
}

sub display_host {
	my ($host, $all) = @_;

	if ($all and (not $short or $extra->{$host}->{service_problem})) {
		say "\n$host";
	}

	foreach my $service (@{$data->{services}->{$host}}) {

		if ($short and not $service->{current_state}) {
			next;
		}

		if ($all) {
			print "\t";
		}

		display_service($service);
	}
}

GetOptions(
	'C|no-colours'    => sub { $colours = 0 },
	'f|status-file=s' => \$status_file,
	'h|host=s'        => \$for_host,
	's|short'         => \$short,
);

read_status();

if ($for_host) {
	if (exists $data->{services}->{$for_host}) {
		display_host($for_host, 0);
	}
	else {
		die("Unknown host: $for_host (You need to use the Alias name)\n");
	}
}
else {
	foreach my $host (sort keys %{$data->{services}}) {
		display_host($host, 1);
	}
}

__END__

=head1 NAME

B<icli> - Icinga Command Line Interface

=head1 SYNOPSIS

B<icli> [B<-h> I<host>]

=head1 DESCRIPTION

B<icli> is a command line interface to Icinga. By default it lists all
services and their states.

=head1 OPTIONS

=over

=item B<-C>/B<--no-colours>

Disable colours in output

=item B<-f>/B<--status-file> I<file>

Read the status from I<file> instead of the default
F</var/lib/icinga/status.dat>

=item B<-h>/B<--host> I<host>

Only show I<host>'s services

=item B<-s>/B<--short>

Only show services which are not OK

=back

=head1 EXIT STATUS

Zero, unless errors occured.

=head1 CONFIGURATION

None.

=head1 DEPENDENCIES

None, so far.

=head1 BUGS AND LIMITATIONS

This software is in early development stages. So there will probably be quite
a lot.

=head1 AUTHOR

Copyright (C) 2010 by Daniel Friesel E<lt>derf@chaosdorf.deE<gt>

=head1 LICENSE

  0. You just DO WHAT THE FUCK YOU WANT TO.
